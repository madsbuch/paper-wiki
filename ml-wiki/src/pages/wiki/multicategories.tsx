import WikiLayout from '../../components/WikiLayout';
import { useState } from 'react';

export const meta = {
  title: "Multicategories",
  description: "Multi-ary generalizations of categories where morphisms can have multiple inputs and one output, providing natural models for type theories with multiple variables in context",
  category: "Category Theory",
  tags: ["Category Theory", "Type Theory", "Semantics", "Multi-ary Structures"],
  citations: [
    {
      paper: "Clones, closed categories, and combinatory logic",
      authors: "Saville, P.",
      year: "2024",
      pages: "4-6"
    }
  ],
  relatedConcepts: ["abstract-clones", "closed-categories", "combinatory-logic"]
};

export default function Multicategories() {
  const [showAnswer, setShowAnswer] = useState(false);

  return (
    <WikiLayout {...meta}>
      <section>
        <h2>Overview</h2>
        <p>
          A multicategory is a generalization of a category where morphisms (called multimaps)
          can have multiple inputs but still only one output. This matches the structure of
          terms-in-context from type theory, where a term like <code>x₁: A₁, ..., xₙ: Aₙ ⊢ t: B</code> has
          multiple typed variables in its context.
        </p>

        <p>
          Multicategories were introduced by Lambek [Lambek, 1969] and provide a natural framework
          for modeling ordered type theories that do not admit structural rules like weakening,
          contraction, or permutation [Saville, 2024, p. 4].
        </p>
      </section>

      <section>
        <h2>Definition</h2>
        <p>
          A multicategory <strong>M</strong> consists of:
        </p>
        <ul>
          <li>A set |M| of <strong>objects</strong></li>
          <li>For every sequence Γ = (A₁, ..., Aₙ) of objects and object B, a set M(Γ; B) of
              <strong>multimaps</strong> from Γ to B</li>
          <li>An <strong>identity multimap</strong> Idₐ ∈ M(A; A) for every object A</li>
          <li>A <strong>composition operation</strong> that combines multimaps</li>
        </ul>

        <p>
          The composition operation takes a multimap <code>t: A₁, ..., Aₙ → B</code> and multimaps
          <code>(uᵢ: Δᵢ → Aᵢ)</code> for i = 1, ..., n, and produces a multimap
          <code>t ∘ ⟨u₁, ..., uₙ⟩: Δ₁, ..., Δₙ → B</code> [Saville, 2024, p. 5].
        </p>

        <p>
          This composition must satisfy:
        </p>
        <ul>
          <li><strong>Associativity</strong>: Composition is associative</li>
          <li><strong>Unit laws</strong>: Identity multimaps act as identities for composition</li>
        </ul>
      </section>

      <section>
        <h2>Connection to Type Theory</h2>
        <p>
          Multicategories have a natural interpretation as type theories. Each multimap
          <code>t: A₁, ..., Aₙ → B</code> corresponds to a term-in-context
          <code>x₁: A₁, ..., xₙ: Aₙ ⊢ t: B</code> [Saville, 2024, p. 5].
        </p>

        <p>
          The identity multimap Idₐ corresponds to a variable <code>x: A</code>, and the
          composition operation becomes a formal substitution operation on the language. The
          three axioms (associativity and two unit laws) become well-known properties of
          substitution in type theory.
        </p>

        <h3>Internal Language</h3>
        <p>
          Every multicategory has an internal language with terms generated by:
        </p>
        <ul>
          <li><strong>Variables</strong>: <code>x: A ⊢ x: A</code></li>
          <li><strong>Constants</strong>: For each c ∈ S(Γ; B), we have <code>Δ₁, ..., Δₙ ⊢ c§(u₁, ..., uₙ): B</code>
              when <code>(Δᵢ ⊢ uᵢ: Aᵢ)</code></li>
        </ul>
      </section>

      <section>
        <h2>Variants</h2>

        <h3>Symmetric Multicategories</h3>
        <p>
          A <strong>symmetric multicategory</strong> additionally has a symmetric group action:
          for each permutation σ ∈ Sₙ, there is an operation that reorders the inputs of a
          multimap. This models linear type theories that admit the exchange rule (permutation)
          but not weakening or contraction [Saville, 2024, p. 5].
        </p>

        <h3>Relationship to Other Structures</h3>
        <ul>
          <li><strong>Categories</strong>: A category is a multicategory where all multimaps are unary (single input)</li>
          <li><strong>Monoidal Categories</strong>: Every monoidal category (C, ⊗, I) induces a multicategory TC
              where multimaps are defined using the tensor product [Saville, 2024, p. 5]</li>
          <li><strong>Clones</strong>: Abstract clones are multicategories with additional cartesian structure
              (weakening and contraction)</li>
        </ul>
      </section>

      <section>
        <h2>The Orchestra Analogy</h2>
        <p>
          Think of a multicategory like an orchestra preparing for a performance. Each multimap is like
          a musical arrangement that takes multiple instrumental parts as input and produces a unified
          performance as output.
        </p>

        <p>
          For example, a symphony might require parts for violins (A₁), cellos (A₂), and trumpets (A₃),
          and produce a complete movement (B). The multimap <code>symphony: A₁, A₂, A₃ → B</code> specifies
          how these parts combine.
        </p>

        <p>
          Composition is like rehearsal sections combining. If the violins need to practice their part
          first (u₁: Δ₁ → A₁), and similarly for other sections, then the full rehearsal is the composition
          <code>symphony ∘ ⟨u₁, u₂, u₃⟩</code>.
        </p>

        <p>
          In an <strong>ordered</strong> multicategory, the musicians must play in strict sequence—no
          swapping violin and cello parts. In a <strong>symmetric</strong> multicategory, you can permute
          which section plays which part. In a <strong>cartesian</strong> multicategory (clone), a section
          can be silent (weakening) or play multiple parts (contraction).
        </p>
      </section>

      <section>
        <h2>Exercise: Understanding Composition</h2>
        <p>
          Consider a multicategory with objects representing types in a programming language.
          You have:
        </p>
        <ul>
          <li>A multimap <code>add: Int, Int → Int</code> that adds two integers</li>
          <li>Multimaps <code>double: Int → Int</code> and <code>triple: Int → Int</code></li>
        </ul>

        <p>
          What is the result of composing <code>add ∘ ⟨double, triple⟩</code>?
        </p>

        <p>
          Apply this to an input context containing a single integer <code>x: Int</code>.
          What multimap do you get?
        </p>

        <button
          onClick={() => setShowAnswer(!showAnswer)}
          className="mt-4 px-4 py-2 bg-violet-500 text-white rounded hover:bg-violet-600 transition-colors"
        >
          {showAnswer ? 'Hide Answer' : 'Show Answer'}
        </button>

        {showAnswer && (
          <div className="mt-4 p-4 bg-green-50 rounded-lg border border-green-200 animate-fadeIn">
            <p className="font-semibold mb-2">Answer:</p>
            <p>
              The composition <code>add ∘ ⟨double, triple⟩</code> has type <code>Int, Int → Int</code>
              because:
            </p>
            <ul className="list-disc ml-6 mt-2">
              <li><code>double: Int → Int</code> takes the first input</li>
              <li><code>triple: Int → Int</code> takes the second input</li>
              <li><code>add</code> then combines these results</li>
            </ul>
            <p className="mt-2">
              When applied to a single integer <code>x: Int</code>, we would need two copies of x,
              which is not possible in a plain multicategory (no contraction). This illustrates
              why cartesian structure (clones) is needed to model programming languages with variable reuse!
            </p>
            <p className="mt-2">
              If we had a cartesian multicategory, the result would be the multimap
              <code>x: Int → add(double(x), triple(x))</code>, which computes <code>2x + 3x = 5x</code>.
            </p>
          </div>
        )}
      </section>

      <section>
        <h2>Applications</h2>
        <p>
          Multicategories provide the foundation for:
        </p>
        <ul>
          <li><strong>Semantics of type theories</strong>: Modeling ordered, linear, and cartesian variants
              of typed λ-calculi</li>
          <li><strong>Universal properties</strong>: Defining products, tensors, and exponentials through
              universal arrows in multicategories [Saville, 2024, p. 7]</li>
          <li><strong>Operads</strong>: Multicategories with a single object are operads, important in
              algebra and topology</li>
          <li><strong>Multi-ary logic</strong>: Providing models for logics where propositions can depend
              on multiple assumptions</li>
        </ul>
      </section>
    </WikiLayout>
  );
}
